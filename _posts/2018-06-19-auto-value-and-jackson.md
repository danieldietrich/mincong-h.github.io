---
layout:      post
title:       "Auto Value and Jackson"
date:        "2018-06-19 07:43:18 +0200"
categories:  [java, serialization, json, auto-value]
comments:    true
---

It has been about 1 month now since I started writing REST APIs for Nuxeo. We
use Google [AutoValue][1] and Jackson for data transfer objects (DTO). Today, I
would like share some feedback with you.

## What is AutoValue?

Value classes are extremely common in Java projects. These are classes for
which you want to treat any two instances with suitably equal field values as
interchangeable. **AutoValue** provides an easier way to create immutable value
classes, with a lot less code and less room for error, while not restricting
your freedom to code almost any aspect of your class exactly the way you want
it.

The class using AutoValue and Jackson looks like:

{% highlight java %}
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.google.auto.value.AutoValue;

@AutoValue
@JsonDeserialize(builder = AutoValue_Company.Builder.class)
public abstract class Company {

  public static Builder newBuilder() {
    return new AutoValue_Company.Builder();
  }

  @JsonProperty("id")
  public abstract long id();

  @JsonProperty("description")
  public abstract String description();

  @JsonProperty("websiteUrl")
  public abstract String websiteUrl();

  @AutoValue.Builder
  public interface Builder {
    @JsonProperty("id")
    Builder id(long id);

    @JsonProperty("description")
    Builder description(String description);

    @JsonProperty("websiteUrl")
    Builder websiteUrl(String url);

    Company build();
  }
}
{% endhighlight %}

Note that we only define the abstract classes. The concrete classes are
generated by AutoValue using Annotation Processor (see [OpenJDK Compilation
Overview][3]):

- `AutoValue_Company.class`
- `AutoValue_Company.Builder.class`

## Jackson

Jackson annotations help Jackson to understand how to serialize and deserialize
the value class.

Action          | Description
:-------------- | :----------
Serialization   | Java -> JSON using value class annotations
Deserialization | JSON -> Java using builder class annotations

When using Jackson in JAX-RS, a Jackson JSON provider needs to be registered as
singleton in the REST application:

{% highlight java %}
import com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("api")
public class RestApplication extends Application {

  ...

  @Override
  public Set<Object> getSingletons() {
    Set<Object> singletons = new HashSet<>();
    singletons.add(new JacksonJsonProvider());
    return singletons;
  }
}
{% endhighlight %}

## AutoValue Advanced Configuration

In the following sections, we'll talk about advanced configuration: ensure the
solution "AutoValue + Jackson" fits your application requirements.

### Optional Value

Some fields might be optional in your AutoValue object. Ordinarily the
generated constructor will reject any `null` values. If you want to accept
`null`, you can either add a `@Nullable` annotation (see [AutoValue: how to
use nullable properties?][5]) or use `Optional<T>`. My preferred one is
`Optional<T>`:

{% highlight java %}
@AutoValue
@JsonDeserialize(builder = AutoValue_User.Builder.class)
public abstract class User {
  /**
   * User description.
   *
   * <p>Optional because user might not want to provide any information.
   */
  @JsonProperty("description")
  public abstract Optional<String> description(); // 1

  ...

  @AutoValue.Builder
  public interface Builder {
    @JsonProperty("description")
    Builder description(Optional<String> description); // 2

    Builder description(String description); // 3

    ...
  }
}
{% endhighlight %}

Note that on the getter side (1), there is only one getter method, which return
optional. On the other side, for setter, there are two setter methods (2)(3),
allowing you to provide a description directly or a wrapped description. For
Jackson, you _must_ annotate the builder method with `Optional<T>` as parameter,
otherwise AutoValue reject the `null` case provided by Jackson.

## Jackson Advanced Configuration
Most of the time, you need to customize the Jackson JSON provider

{% highlight java %}
@ApplicationPath("api")
public class RestApplication extends Application {

  ...

  @Override
  public Set<Object> getSingletons() {
    Set<Object> singletons = new HashSet<>();
    singletons.add(new JacksonJsonProvider(newObjectMapper()));
    return singletons;
  }

  private static ObjectMapper newObjectMapper() {
    ObjectMapper mapper =
        new ObjectMapper()
            .registerModule(new ParameterNamesModule())
            .registerModule(new Jdk8Module())
            .registerModule(new JavaTimeModule()); // new module, NOT JSR310Module
    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
    mapper.setDateFormat(new StdDateFormat());
    return mapper;
  }
}
{% endhighlight %}

## References

- [Google Auto: A collection of source code generators for Java.][1]
- [Jackson: JSON library for Java][2]
- [OpenJDK: Compilation Overview][3]
- [Baeldung: Jackson Tutorial][4]

[1]: https://github.com/google/auto
[2]: https://github.com/FasterXML/jackson
[3]: http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html
[4]: http://www.baeldung.com/jackson
[5]: https://github.com/google/auto/blob/master/value/userguide/howto.md#-use-nullable-properties
